---
layout: post
title: Git reset, when and how to use it
date: 2022-01-03
last_modified_at: 2022-01-03
cover_image: 2022-01-04-feature.png
author: Simon Dosda
categories: git tool
excerpt_separator: <!--more-->
---

[Git reset](https://git-scm.com/docs/git-reset) is part of the git commands that used to confuse me, I did not really understand its purpose or usecases at first.

On top of that, it seemed to be doing very different things depending on its input, either a commit or a path.

But once I dug a bit deeper into each option of this command and understood the logic behind it, which eventually is about undoing changes staged or committed, it really help me to manage my commit history and revert mistakes, particularly in my rebase workflow.

<!--more-->

With this article, I hope I will help you clarify how this command works and how you can use it in your daily development tasks.

## Git reset with a path: unstaging files

When used with a path, the reset command does the opposite of git add: it removes changes from the staging area.

![git reset with a file](/assets/images/2022-01-04-git-reset-file.png)

It is worse noting though that a new command was recently added to git, `git restore`, to fulfill this purpose and will probably become the advised way to perform this action.

For now, `git restore` is still experimental but I think it should be preferred over `git reset` for unstaging changes, as its implementation seems more intuitive, whereas `git reset` should be used to update the branch's head, as we will see after.

But if you want to use the reset command for unstaging files, here are some examples:

```bash
git reset # unstage all changes
git reset file-a file-b # unstage file-a and file-b files
git reset folder-a/ # unstage all changes in the folder folder-a
```

I personally do not use `git reset` for this purpose, I don't deal much with staging my changes, I usually commit everything (I have [set an alias]({ post_url 2021-04-13-git-aliases.html }) for this purpose that I am always using), and if I find myself needing to only commit partial changes, I use my IDE to do so.

## Git reset with a commit: modifying the head of your branch

When used with a commit, `git reset` allows us to change the head of our branch. While doing so, it allows us to extract the changes between our current head and the new one, and put them in our staging area, working directory, or forget them depending on the mode used.

Let's see how the different modes work.

### The soft mode ðŸª¶

The soft mode will keep your current staging area and working tree as it is while moving your head to the specified commit. Changes between your previous head and the new one will be added to the staging area.

![git reset in soft mode](/assets/images/2022-01-04-git-reset-soft.png)

This option can be really useful if you want to rewrite your history in only one commit, instead of using an interactive `rebase` to squash your commits:

```bash
git reset --soft main
git commit -m 'feat: an atomic feature'
```

### The mixed mode ðŸ¥—

Using git reset with the mixed mode (which is the default) removes everything from the staging area, but keeps the changes in the working directory.

![git reset in mixed mode](/assets/images/2022-01-04-git-reset-mixed.png)

This option can be really useful if you want to rewrite your history in several commits, for instance creating two commits from all the changes you made from your main branch:

```bash
git reset --mixed main
git commit --interactive -m 'fix: a correction aside the main feature'
git commit --all -m 'feat: the main feature'

```

### The hard mode ðŸª¨

This is the heavy-handed one, it sets the index to the given commit and removes all changes between your previous and current index or in your working directory.

![git reset in hard mode](/assets/images/2022-01-04-git-reset-hard.png)

This can be really useful if you want to get rid of your current changes:

```bash
git reset --hard HEAD # or just git reset --hard
```

NB: use this command only if you know you are not interested in keeping your current changes, as you will not be able to recover them. If you are not sure yet but what to start back from your last commit, use `git stash` instead to put your current changes aside.

Another interesting use-case is to reset your branch to the state of the remote one (a kind of force pull):

```bash
git reset --hard origin/my-branch
```

### The keep mode âœŠ

This mode is a bit peculiar, it is quite similar to the hard mode, in the sense that it will drop the commits between your previous and new head. But it will carry on your unstaged changes, and abort if there is any conflict between these changes and the removed commits.

![git reset in keep mode](/assets/images/2022-01-04-git-reset-keep.png)

This command is really dedicated to doing one thing: remove commits while being safe that it won't conflict with our current unstaged changes. I donâ€™t really find myself in this kind of situation, but if that happens I guess it can be valuable to know this option.

### What about the merge mode?

As explained in the documentation, `reset --merge` is meant to be used when resetting out of a conflicted merge. Which is a very specific situation, and as I donâ€™t use `merge` in my workflow, I never have the use for this command.

But do not hesitate to [read the documentation](https://git-scm.com/docs/git-reset) if you think you might be interested.
